/******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./assets/js/public/modules/modals/popup.js":
/*!**************************************************!*\
  !*** ./assets/js/public/modules/modals/popup.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/**
 * Popup Modal Module
 */

/* harmony default export */ __webpack_exports__["default"] = ({});

/***/ }),

/***/ "./assets/js/public/modules/utilities/tracker.js":
/*!*******************************************************!*\
  !*** ./assets/js/public/modules/utilities/tracker.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/**
 * CTA Manager - Click Tracker
 *
 * Tracks click events on call buttons via AJAX,
 * handles nonce validation, and sends analytics data.
 */

(function (window) {
  'use strict';

  /**
   * Click Tracker Object
   */
  var CTATracker = {
    // Configuration
    nonce: null,
    ajaxUrl: null,
    trackingEnabled: true,
    autoImpressionsEnabled: true,
    debug: false,
    // Track which CTAs have already had impressions recorded this session
    impressionsSent: {},
    // Track which CTAs have had a page view recorded this session
    pageViewsSent: {},
    // Intersection observer instance
    impressionObserver: null,
    /**
     * Initialize tracker
     */
    init: function () {
      // Check for WordPress globals
      if (typeof ctaTrackerVars === 'undefined' && typeof ctaPublic !== 'undefined') {
        window.ctaTrackerVars = ctaPublic;
      }
      if (typeof ctaTrackerVars === 'undefined') {
        this.debug && console.warn('CTC Tracker: Missing localization variables');
        return false;
      }
      this.nonce = ctaTrackerVars.nonce;
      this.ajaxUrl = ctaTrackerVars.ajaxUrl;
      this.trackingEnabled = ctaTrackerVars.trackingEnabled !== false;
      this.autoImpressionsEnabled = ctaTrackerVars.autoImpressionsEnabled !== false;
      this.debug = ctaTrackerVars.debug === true;
      this.attachListeners();
      return true;
    },
    /**
     * Attach event listeners to call buttons
     */
    attachListeners: function () {
      var self = this;
      var buttonSelectors = ['.cta-button', '[data-cta-button]', 'a[href^="tel:"]'];

      // Use event delegation for dynamic content
      document.addEventListener('click', function (e) {
        // Check if clicked element or parent is a call button
        var target = e.target;
        var button = null;

        // Traverse up to find button
        while (target && target !== document) {
          if (self.isCallButton(target)) {
            button = target;
            break;
          }
          target = target.parentNode;
        }
        if (button && self.trackingEnabled) {
          self.trackClick(button, e);
        }
      }, true);
      this.debug && console.log('CTC Tracker: Listeners attached');
    },
    /**
     * Check if element is a call button
     */
    isCallButton: function (element) {
      // Check for CTA button class
      if (element.classList && element.classList.contains('cta-button')) {
        return true;
      }

      // Check for data attribute
      if (element.getAttribute && element.getAttribute('data-cta-button') !== null) {
        return true;
      }

      // Check for tel: href
      var href = element.getAttribute ? element.getAttribute('href') : null;
      if (href && href.substring(0, 4) === 'tel:') {
        return true;
      }
      return false;
    },
    /**
     * Track click event
     */
    trackClick: function (button, event) {
      // Don't prevent default action
      // Only track after allowing default behavior

      var trackData = this.buildTrackingData(button, event);
      trackData.event_type = 'click';
      this.debug && console.log('CTC Tracker: Tracking click', trackData);

      // Send tracking data via AJAX
      this.sendTrackingData(trackData);
    },
    /**
     * Build tracking data object
     */
    buildTrackingData: function (button, event) {
      var data = {
        event_type: 'click',
        // Button information
        phone_number: this.extractPhoneNumber(button),
        button_text: this.getButtonText(button),
        button_size: this.getButtonSize(button),
        cta_id: this.getCTAId(button),
        cta_title: button.getAttribute('data-cta-title') || '',
        // Page information
        page_url: window.location.href,
        page_title: document.title,
        referrer: document.referrer,
        // Device information
        user_agent: navigator.userAgent,
        viewport_width: window.innerWidth,
        viewport_height: window.innerHeight,
        // Timestamp
        timestamp: new Date().toISOString(),
        // Session data
        session_id: this.getSessionId(),
        // Additional context
        button_id: button.getAttribute('id') || '',
        button_class: button.getAttribute('class') || ''
      };
      return data;
    },
    /**
     * Get CTA ID from data attribute
     */
    getCTAId: function (button) {
      var id = button.getAttribute('data-cta-id');
      return id ? parseInt(id, 10) : 0;
    },
    /**
     * Extract phone number from button
     */
    extractPhoneNumber: function (button) {
      // Try href attribute first
      var href = button.getAttribute('href');
      if (href && href.substring(0, 4) === 'tel:') {
        return href.substring(4);
      }

      // Try data attribute
      var phoneData = button.getAttribute('data-phone');
      if (phoneData) {
        return phoneData;
      }

      // Try aria-label or title
      var label = button.getAttribute('aria-label') || button.getAttribute('title') || '';
      var phoneMatch = label.match(/[\d\s\-\+\(\)]+/);
      if (phoneMatch) {
        return phoneMatch[0];
      }
      return '';
    },
    /**
     * Track impressions for all CTAs on page
     * Only runs if autoImpressionsEnabled is true
     */
    trackImpressions: function () {
      // Skip if auto impressions are disabled
      if (!this.autoImpressionsEnabled) {
        this.debug && console.log('CTC Tracker: Auto impressions disabled, use triggerImpression() manually');
        return;
      }
      this.setupImpressionObserver();
    },
    /**
     * Setup an observer to track impressions only when CTAs enter the viewport
     */
    setupImpressionObserver: function () {
      var self = this;
      var buttons = document.querySelectorAll('[data-cta-id]');
      if (!buttons.length || !this.trackingEnabled) return;

      // Prefer IntersectionObserver for accurate in-view impressions
      if ('IntersectionObserver' in window) {
        if (this.impressionObserver) {
          this.impressionObserver.disconnect();
        }
        this.impressionObserver = new IntersectionObserver(function (entries) {
          entries.forEach(function (entry) {
            if (entry.isIntersecting || entry.intersectionRatio >= 0.5) {
              self.recordImpressionForElement(entry.target);
              self.impressionObserver && self.impressionObserver.unobserve(entry.target);
            }
          });
        }, {
          threshold: [0.5]
        });
        buttons.forEach(function (btn) {
          self.impressionObserver.observe(btn);
        });
        return;
      }

      // Fallback: check visibility on scroll/resize
      var checkVisibility = function () {
        buttons.forEach(function (btn) {
          if (self.isElementInView(btn, 0.5)) {
            self.recordImpressionForElement(btn);
          }
        });
      };
      checkVisibility();
      window.addEventListener('scroll', checkVisibility, {
        passive: true
      });
      window.addEventListener('resize', checkVisibility);
    },
    /**
     * Track a page view for CTAs present on the page
     */
    trackPageViews: function () {
      if (!this.trackingEnabled) return;
      var buttons = document.querySelectorAll('[data-cta-id]');
      if (!buttons.length) return;
      var payload = [];
      var seen = {};
      buttons.forEach(function (btn) {
        var ctaId = btn.getAttribute('data-cta-id');
        if (!ctaId || seen[ctaId]) return;
        if (this.pageViewsSent[ctaId]) return;
        seen[ctaId] = true;
        this.pageViewsSent[ctaId] = true;
        payload.push({
          cta_id: parseInt(ctaId, 10),
          cta_title: btn.getAttribute('data-cta-title') || '',
          page_url: window.location.href,
          page_title: document.title,
          event_type: 'page_view'
        });
      }, this);
      if (!payload.length) return;
      var formData = new FormData();
      formData.append('action', 'cta_track_page_view');
      formData.append('nonce', this.nonce);
      formData.append('data', JSON.stringify(payload));
      if (navigator.sendBeacon) {
        navigator.sendBeacon(this.ajaxUrl, formData);
      } else {
        this.sendViaXHRPayload('cta_track_page_view', payload);
      }
    },
    /**
     * Record impression for a CTA element (when it comes into view)
     */
    recordImpressionForElement: function (btn) {
      var ctaId = btn.getAttribute('data-cta-id');
      if (!ctaId) return;
      if (this.impressionsSent[ctaId]) return;
      this.impressionsSent[ctaId] = true;
      var impressionData = {
        cta_id: parseInt(ctaId, 10),
        cta_title: btn.getAttribute('data-cta-title') || '',
        page_url: window.location.href,
        page_title: document.title,
        event_type: 'impression'
      };

      // Dispatch cta:impression event
      this.dispatchImpressionEvent(btn, impressionData);
      var payload = [impressionData];
      var formData = new FormData();
      formData.append('action', 'cta_track_impression');
      formData.append('nonce', this.nonce);
      formData.append('data', JSON.stringify(payload));
      if (navigator.sendBeacon) {
        navigator.sendBeacon(this.ajaxUrl, formData);
      } else {
        this.sendViaXHRPayload('cta_track_impression', payload);
      }
    },
    /**
     * Check if element is at least threshold visible in viewport
     */
    isElementInView: function (el, threshold) {
      threshold = typeof threshold === 'number' ? threshold : 0.5;
      var rect = el.getBoundingClientRect();
      var windowHeight = window.innerHeight || document.documentElement.clientHeight;
      var windowWidth = window.innerWidth || document.documentElement.clientWidth;
      if (rect.width === 0 || rect.height === 0) return false;
      var verticalVisible = Math.max(0, Math.min(rect.bottom, windowHeight) - Math.max(rect.top, 0));
      var horizontalVisible = Math.max(0, Math.min(rect.right, windowWidth) - Math.max(rect.left, 0));
      var visibleArea = verticalVisible * horizontalVisible;
      var totalArea = rect.width * rect.height;
      return totalArea > 0 && visibleArea / totalArea >= threshold;
    },
    /**
     * Manually trigger an impression for a specific CTA
     * Use this when auto impressions are disabled or for CTAs that appear dynamically
     *
     * @param {number|string|Element} ctaIdOrElement - CTA ID, CSS selector, or DOM element
     * @param {Object} options - Optional settings
     * @param {boolean} options.force - Force re-recording even if already tracked this session
     * @returns {boolean} Whether the impression was triggered
     */
    triggerImpression: function (ctaIdOrElement, options) {
      options = options || {};
      var self = this;
      if (!this.trackingEnabled) {
        this.debug && console.warn('CTC Tracker: Tracking is disabled');
        return false;
      }

      // Find the element(s)
      var elements = [];
      if (typeof ctaIdOrElement === 'number' || typeof ctaIdOrElement === 'string' && !isNaN(ctaIdOrElement)) {
        // It's a CTA ID - find elements with this ID
        elements = document.querySelectorAll('[data-cta-id="' + ctaIdOrElement + '"]');
      } else if (typeof ctaIdOrElement === 'string') {
        // It's a CSS selector
        elements = document.querySelectorAll(ctaIdOrElement);
      } else if (ctaIdOrElement instanceof Element) {
        // It's a DOM element
        elements = [ctaIdOrElement];
      } else if (ctaIdOrElement && ctaIdOrElement.length) {
        // It's a NodeList or array
        elements = ctaIdOrElement;
      }
      if (!elements.length) {
        this.debug && console.warn('CTC Tracker: No elements found for impression');
        return false;
      }
      var payload = [];
      var triggered = false;
      Array.prototype.forEach.call(elements, function (element) {
        var ctaId = element.getAttribute('data-cta-id');
        if (!ctaId) {
          self.debug && console.warn('CTC Tracker: Element missing data-cta-id attribute');
          return;
        }

        // Check if already tracked (unless force is true)
        if (!options.force && self.impressionsSent[ctaId]) {
          self.debug && console.log('CTC Tracker: Impression already recorded for CTA', ctaId);
          return;
        }
        self.impressionsSent[ctaId] = true;
        triggered = true;
        var impressionData = {
          cta_id: parseInt(ctaId, 10),
          cta_title: element.getAttribute('data-cta-title') || '',
          page_url: window.location.href,
          page_title: document.title,
          event_type: 'impression'
        };
        payload.push(impressionData);

        // Dispatch cta:impression event
        self.dispatchImpressionEvent(element, impressionData);
        self.debug && console.log('CTC Tracker: Manual impression triggered for CTA', ctaId);
      });
      if (!payload.length) return false;

      // Send to server
      var formData = new FormData();
      formData.append('action', 'cta_track_impression');
      formData.append('nonce', this.nonce);
      formData.append('data', JSON.stringify(payload));
      if (navigator.sendBeacon) {
        navigator.sendBeacon(this.ajaxUrl, formData);
      } else {
        this.sendViaXHRPayload('cta_track_impression', payload);
      }
      return triggered;
    },
    /**
     * Dispatch cta:impression CustomEvent
     *
     * @param {Element} element - The CTA element
     * @param {Object} data - Impression data
     */
    dispatchImpressionEvent: function (element, data) {
      var event = new CustomEvent('cta:impression', {
        bubbles: true,
        detail: {
          ctaId: data.cta_id,
          ctaTitle: data.cta_title,
          layout: element.getAttribute('data-cta-layout') || 'button',
          pageUrl: data.page_url,
          device: this.getDeviceType()
        }
      });
      document.dispatchEvent(event);
      this.debug && console.log('CTC Tracker: Dispatched cta:impression event', event.detail);
    },
    /**
     * Get device type based on viewport width
     *
     * @returns {string} 'mobile', 'tablet', or 'desktop'
     */
    getDeviceType: function () {
      var width = window.innerWidth;
      if (width < 768) return 'mobile';
      if (width < 1024) return 'tablet';
      return 'desktop';
    },
    /**
     * Get button text
     */
    getButtonText: function (button) {
      return button.textContent.trim() || button.innerText.trim() || '';
    },
    /**
     * Get button size
     */
    getButtonSize: function (button) {
      var classes = button.getAttribute('class') || '';
      if (classes.indexOf('sm') !== -1) return 'sm';
      if (classes.indexOf('lg') !== -1) return 'lg';
      if (classes.indexOf('xl') !== -1) return 'xl';
      return 'md';
    },
    /**
     * Get or create session ID
     */
    getSessionId: function () {
      var sessionKey = 'cta_session_id';
      var sessionId = this.getSessionStorage(sessionKey);
      if (!sessionId) {
        sessionId = this.generateUUID();
        this.setSessionStorage(sessionKey, sessionId);
      }
      return sessionId;
    },
    /**
     * Get value from session storage
     */
    getSessionStorage: function (key) {
      try {
        return sessionStorage.getItem(key);
      } catch (e) {
        this.debug && console.warn('CTC Tracker: SessionStorage unavailable', e);
        return null;
      }
    },
    /**
     * Set value in session storage
     */
    setSessionStorage: function (key, value) {
      try {
        sessionStorage.setItem(key, value);
      } catch (e) {
        this.debug && console.warn('CTC Tracker: SessionStorage unavailable', e);
      }
    },
    /**
     * Generate UUID v4
     */
    generateUUID: function () {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = Math.random() * 16 | 0;
        var v = c === 'x' ? r : r & 0x3 | 0x8;
        return v.toString(16);
      });
    },
    /**
     * Send tracking data via AJAX
     */
    sendTrackingData: function (trackData) {
      var self = this;
      if (!this.nonce || !this.ajaxUrl) {
        this.debug && console.warn('CTC Tracker: Missing AJAX configuration');
        return;
      }

      // Use sendBeacon for reliability (fires even if page unloads)
      var beaconData = this.buildBeaconData(trackData);
      if (navigator.sendBeacon) {
        try {
          navigator.sendBeacon(this.ajaxUrl, beaconData);
          self.debug && console.log('CTC Tracker: Beacon sent');
        } catch (e) {
          // Fallback to XMLHttpRequest
          this.sendViaXHR(trackData);
        }
      } else {
        // Fallback to XMLHttpRequest
        this.sendViaXHR(trackData);
      }
    },
    /**
     * Build beacon form data
     */
    buildBeaconData: function (trackData) {
      var formData = new FormData();
      formData.append('action', 'cta_track_click');
      formData.append('nonce', this.nonce);
      formData.append('data', JSON.stringify(trackData));
      return formData;
    },
    /**
     * Send data via XMLHttpRequest
     */
    sendViaXHR: function (trackData) {
      var self = this;

      // Use XMLHttpRequest with async: false to ensure it completes
      var xhr = new XMLHttpRequest();
      xhr.open('POST', this.ajaxUrl, true);
      xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
      var data = 'action=cta_track_click&nonce=' + encodeURIComponent(this.nonce) + '&data=' + encodeURIComponent(JSON.stringify(trackData));
      xhr.onload = function () {
        if (xhr.status === 200) {
          self.debug && console.log('CTC Tracker: Click tracked successfully');
        } else {
          self.debug && console.warn('CTC Tracker: Tracking request failed', xhr.status);
        }
      };
      xhr.onerror = function () {
        self.debug && console.error('CTC Tracker: Network error');
      };
      xhr.send(data);
    },
    sendViaXHRPayload: function (action, payload) {
      var xhr = new XMLHttpRequest();
      xhr.open('POST', this.ajaxUrl, true);
      xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
      var data = 'action=' + encodeURIComponent(action) + '&nonce=' + encodeURIComponent(this.nonce) + '&data=' + encodeURIComponent(JSON.stringify(payload));
      xhr.send(data);
    },
    /**
     * Reset tracking (for testing)
     */
    reset: function () {
      try {
        sessionStorage.removeItem('cta_session_id');
      } catch (e) {
        // ignore
      }
    },
    /**
     * Get current session ID (for debugging)
     */
    getSessionInfo: function () {
      return {
        sessionId: this.getSessionId(),
        trackingEnabled: this.trackingEnabled,
        autoImpressionsEnabled: this.autoImpressionsEnabled,
        impressionsSent: Object.keys(this.impressionsSent),
        nonce: this.nonce ? 'set' : 'not set',
        ajaxUrl: this.ajaxUrl ? 'set' : 'not set'
      };
    },
    /**
     * Check if auto impressions are enabled
     *
     * @returns {boolean}
     */
    isAutoImpressionsEnabled: function () {
      return this.autoImpressionsEnabled;
    },
    /**
     * Check if an impression has been recorded for a CTA this session
     *
     * @param {number|string} ctaId - The CTA ID to check
     * @returns {boolean}
     */
    hasImpression: function (ctaId) {
      return !!this.impressionsSent[ctaId];
    },
    /**
     * Reset impression tracking for a specific CTA or all CTAs
     *
     * @param {number|string|null} ctaId - CTA ID to reset, or null to reset all
     */
    resetImpressions: function (ctaId) {
      if (ctaId) {
        delete this.impressionsSent[ctaId];
      } else {
        this.impressionsSent = {};
      }
    }
  };

  /**
   * Initialize when DOM is ready
   */
  function initTracker() {
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', function () {
        CTATracker.init();
        CTATracker.trackPageViews();
        CTATracker.trackImpressions();
      });
    } else {
      CTATracker.init();
      CTATracker.trackPageViews();
      CTATracker.trackImpressions();
    }
  }

  /**
   * Expose global API
   */
  window.CTATracker = CTATracker;

  // Initialize automatically
  initTracker();
})(window);
// ES6 Export
/* harmony default export */ __webpack_exports__["default"] = (CTATracker);

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Check if module exists (development only)
/******/ 		if (__webpack_modules__[moduleId] === undefined) {
/******/ 			var e = new Error("Cannot find module '" + moduleId + "'");
/******/ 			e.code = 'MODULE_NOT_FOUND';
/******/ 			throw e;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be isolated against other modules in the chunk.
!function() {
/*!***********************************************!*\
  !*** ./assets/js/public/components/public.js ***!
  \***********************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _modules_modals_popup__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modules/modals/popup */ "./assets/js/public/modules/modals/popup.js");
/* harmony import */ var _modules_utilities_tracker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../modules/utilities/tracker */ "./assets/js/public/modules/utilities/tracker.js");
/**
 * CTA Manager - Public Entry Point
 *
 * Main entry point for public-facing CTA functionality.
 * Handles popup modals and click tracking.
 *
 * When bundled with npm, this file will import:
 * - modals/popup       (popup modal functionality)
 * - utilities/tracker  (click tracking)
 *
 * Output: /assets/js/minimized/public/public.js
 *
 * @package CTA_Manager
 * @since 1.0.0
 */

// ES6 Module Imports (uncomment when bundling with npm)


(function ($) {
  'use strict';

  /**
   * Public CTA Controller
   */
  window.CTAPublic = window.CTAPublic || {
    /**
     * Required modules
     */
    modules: {
      popup: 'CTAPopup',
      tracker: 'CTATracker'
    },
    /**
     * Initialize public functionality
     */
    init: function () {
      // Modules self-initialize
      // Trigger ready event for external hooks
      $(document).trigger('ctaPublicReady', [this]);
    }
  };

  // Initialize on document ready
  $(function () {
    window.CTAPublic.init();
  });
})(jQuery);
}();
/******/ })()
;
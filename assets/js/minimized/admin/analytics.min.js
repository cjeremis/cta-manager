/******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./assets/js/admin/modules/pages/analytics.js":
/*!****************************************************!*\
  !*** ./assets/js/admin/modules/pages/analytics.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* global Chart, ctaAnalyticsData */

(function ($) {
  'use strict';

  const Analytics = {
    charts: {},
    currentDateStart: null,
    currentDateEnd: null,
    currentCtaId: 'all',
    currentDevice: 'all',
    currentType: 'all',
    compareEnabled: false,
    tooltipElement: null,
    eventPage: 1,
    topPagesClicksPage: 1,
    topPagesImpressionsPage: 1,
    cachedTopCtasData: null,
    cachedDailyStatsData: null,
    topPagesClicksHasData: null,
    topPagesImpressionsHasData: null,
    performanceState: null,
    init: function () {
      this.parseUrlParams();
      this.setupDateDefaults();
      this.attachEventHandlers();
      this.loadData();
      this.initPerformanceList();
      this.tooltipElement = document.getElementById('cta-tooltip');
    },
    parseUrlParams: function () {
      const params = new URLSearchParams(window.location.search);
      const ctaId = params.get('cta_id');
      if (ctaId && ctaId !== 'all') {
        this.currentCtaId = ctaId;
        const ctaFilter = document.getElementById('cta-analytics-cta-filter');
        if (ctaFilter) {
          ctaFilter.value = ctaId;
        }
        this.updateFilterSummary();
      }
    },
    setupDateDefaults: function () {
      const today = new Date();
      const retentionDays = parseInt(ctaAnalyticsData.retentionDays, 10);
      const fallbackDays = Number.isFinite(retentionDays) && retentionDays > 0 ? retentionDays : 7;
      let startDate = new Date(today);
      if (ctaAnalyticsData.retentionStartDate) {
        startDate = new Date(`${ctaAnalyticsData.retentionStartDate}T00:00:00`);
      } else {
        startDate.setDate(startDate.getDate() - fallbackDays);
      }
      const formatDate = date => date.toISOString().split('T')[0];
      document.getElementById('cta-analytics-from').value = formatDate(startDate);
      document.getElementById('cta-analytics-to').value = formatDate(today);
      this.currentDateStart = formatDate(startDate);
      this.currentDateEnd = formatDate(today);
      this.applyRetentionClamp();

      // Update filter summary display
      this.updateFilterSummary();
    },
    updateFilterSummary: function () {
      // Format and display date range
      const fromDate = new Date(this.currentDateStart + 'T00:00:00');
      const toDate = new Date(this.currentDateEnd + 'T00:00:00');
      const formatDisplayDate = date => {
        return date.toLocaleDateString('en-US', {
          month: 'short',
          day: 'numeric',
          year: 'numeric'
        });
      };
      const dateRangeText = `${formatDisplayDate(fromDate)} — ${formatDisplayDate(toDate)}`;
      const dateDisplayEl = document.getElementById('cta-filter-date-display');
      if (dateDisplayEl) {
        dateDisplayEl.textContent = dateRangeText;
      }

      // Count active filters (CTA filter + event type filters)
      let filterCount = 0;
      const ctaFilter = document.getElementById('cta-analytics-cta-filter');
      const impressionFilter = document.querySelector('input[name="event_types[]"][value="impression"]');
      const clickFilter = document.querySelector('input[name="event_types[]"][value="click"]');
      if (ctaFilter && ctaFilter.value) {
        filterCount++;
      }

      // If not both event types are selected, count as a filter
      if (impressionFilter && clickFilter) {
        const impressionChecked = impressionFilter.checked;
        const clickChecked = clickFilter.checked;
        if (!(impressionChecked && clickChecked)) {
          filterCount++;
        }
      }

      // Show/hide filter count badge
      const filterCountEl = document.getElementById('cta-filter-count');
      const activeCountEl = document.getElementById('cta-active-filter-count');
      if (filterCountEl && activeCountEl) {
        if (filterCount > 0) {
          activeCountEl.textContent = filterCount;
          filterCountEl.style.display = 'inline-flex';
        } else {
          filterCountEl.style.display = 'none';
        }
      }
    },
    attachEventHandlers: function () {
      // Modal open button
      const openFiltersBtn = document.getElementById('cta-open-filters-modal');
      if (openFiltersBtn) {
        openFiltersBtn.addEventListener('click', () => {
          const modal = document.getElementById('cta-analytics-filters-modal');
          if (modal) {
            modal.style.display = 'flex';
          }
        });
      }

      // Modal close buttons (handled by data-close-modal attribute)
      document.querySelectorAll('[data-close-modal]').forEach(el => {
        el.addEventListener('click', e => {
          if (e.target.closest('.cta-modal-overlay') || e.target.closest('.cta-modal-close')) {
            const modal = e.target.closest('.cta-modal');
            if (modal) {
              modal.style.display = 'none';
            }
          }
        });
      });
      const applyFiltersBtn = document.getElementById('cta-apply-filters');
      if (applyFiltersBtn) {
        applyFiltersBtn.addEventListener('click', () => {
          this.eventPage = 1;
          this.updateFilterSummary();
          // Close modal after applying filters
          const modal = document.getElementById('cta-analytics-filters-modal');
          if (modal) {
            modal.style.display = 'none';
          }
          this.loadData();
        });
      }
      const resetFiltersBtn = document.getElementById('cta-reset-filters');
      if (resetFiltersBtn) {
        resetFiltersBtn.addEventListener('click', () => {
          this.setupDateDefaults();
          this.currentCtaId = 'all';
          this.currentDevice = 'all';
          this.currentType = 'all';
          this.compareEnabled = false;
          const ctaFilterEl = document.getElementById('cta-analytics-cta-filter');
          if (ctaFilterEl) {
            ctaFilterEl.value = '';
          }
          this.eventPage = 1;
          this.updateFilterSummary();
          // Close modal after resetting filters
          const modal = document.getElementById('cta-analytics-filters-modal');
          if (modal) {
            modal.style.display = 'none';
          }
          this.loadData();
        });
      }
      const ctaFilterInput = document.getElementById('cta-analytics-cta-filter');
      if (ctaFilterInput) {
        ctaFilterInput.addEventListener('change', e => {
          this.currentCtaId = e.target.value || 'all';
          this.eventPage = 1;
        });
      }
      const tableSearchInput = document.getElementById('cta-table-search');
      if (tableSearchInput) {
        tableSearchInput.addEventListener('input', () => {
          this.eventPage = 1;
          this.loadEvents();
        });
      }
      const tableEventTypeSelect = document.getElementById('cta-table-event-type');
      if (tableEventTypeSelect) {
        tableEventTypeSelect.addEventListener('change', () => {
          this.eventPage = 1;
          this.loadEvents();
        });
      }
      if (ctaAnalyticsData.isPro) {
        document.getElementById('cta-export-csv')?.addEventListener('click', () => this.exportData('csv'));
        document.getElementById('cta-export-json')?.addEventListener('click', () => this.exportData('json'));
      }

      // Hide tooltip on scroll
      document.addEventListener('scroll', () => this.hideTooltip(), {
        passive: true
      });
      document.addEventListener('keydown', e => {
        if (e.key === 'Escape') this.hideTooltip();
      });
    },
    loadData: function () {
      this.currentDateStart = document.getElementById('cta-analytics-from').value;
      this.currentDateEnd = document.getElementById('cta-analytics-to').value;
      this.applyRetentionClamp();

      // Reset pagination for new data load
      this.topPagesClicksPage = 1;
      this.topPagesImpressionsPage = 1;

      // Reset top pages data tracking (set to null to indicate pending)
      this.topPagesClicksHasData = null;
      this.topPagesImpressionsHasData = null;

      // Always attempt to load analytics (even if initial empty state is shown)
      // so new data within the retention window renders without a full reload.

      Promise.all([this.fetchDailyStats(), this.fetchTypeStats(), this.fetchTopCtas(), this.loadEvents(), this.fetchTopPagesByClicks(), this.fetchTopPagesByImpressions()]);
    },
    applyRetentionClamp: function () {
      if (!ctaAnalyticsData.retentionStartDate) {
        return;
      }
      const minDate = ctaAnalyticsData.retentionStartDate;
      if (this.currentDateStart < minDate) {
        this.currentDateStart = minDate;
        document.getElementById('cta-analytics-from').value = minDate;
      }
      if (this.currentDateEnd < this.currentDateStart) {
        this.currentDateEnd = this.currentDateStart;
        document.getElementById('cta-analytics-to').value = this.currentDateEnd;
      }
    },
    fetchDailyStats: function () {
      return fetch(`${ctaAnalyticsData.ajaxUrl}?action=rest_route&route=/cta-analytics/v1/daily-stats&start_date=${this.currentDateStart}&end_date=${this.currentDateEnd}&cta_id=${this.currentCtaId}`, {
        credentials: 'same-origin'
      }).then(r => r.json()).then(data => {
        if (!data || typeof data !== 'object') {
          throw new Error('Daily stats returned invalid payload');
        }
        const normalizedData = {
          dates: Array.isArray(data.dates) ? data.dates : [],
          ctas: data.ctas && typeof data.ctas === 'object' ? data.ctas : {},
          data: data.data && typeof data.data === 'object' ? data.data : {}
        };
        this.cachedDailyStatsData = normalizedData;
        this.renderDailyCharts(normalizedData);
        this.updateKPIs(normalizedData);
        this.renderCTRTrendChart(normalizedData);
      }).catch(err => console.error('Error fetching daily stats:', err));
    },
    fetchTypeStats: function () {
      return fetch(`${ctaAnalyticsData.ajaxUrl}?action=rest_route&route=/cta-analytics/v1/type-stats&start_date=${this.currentDateStart}&end_date=${this.currentDateEnd}&cta_id=${this.currentCtaId}`, {
        credentials: 'same-origin'
      }).then(r => r.json()).then(data => this.renderTypeCharts(data)).catch(err => console.error('Error fetching type stats:', err));
    },
    fetchTopCtas: function () {
      return fetch(`${ctaAnalyticsData.ajaxUrl}?action=rest_route&route=/cta-analytics/v1/top-ctas&start_date=${this.currentDateStart}&end_date=${this.currentDateEnd}`, {
        credentials: 'same-origin'
      }).then(r => r.json()).then(data => {
        this.cachedTopCtasData = data;
        this.renderTopCtasChart(data);
        this.renderImpressionsShareChart(data);
        this.renderClicksShareChart(data);
      }).catch(err => console.error('Error fetching top CTAs:', err));
    },
    loadEvents: function () {
      // Skip if there's no analytics data
      if (!ctaAnalyticsData.hasAnalyticsData) {
        return Promise.resolve();
      }
      const searchInput = document.getElementById('cta-table-search');
      const eventTypeInput = document.getElementById('cta-table-event-type');
      const search = searchInput ? searchInput.value : '';
      const eventType = eventTypeInput ? eventTypeInput.value : 'all';
      return fetch(`${ctaAnalyticsData.ajaxUrl}?action=rest_route&route=/cta-analytics/v1/events&start_date=${this.currentDateStart}&end_date=${this.currentDateEnd}&event_type=${eventType}&cta_id=${this.currentCtaId}&search=${encodeURIComponent(search)}&page=${this.eventPage}&per_page=50`, {
        credentials: 'same-origin'
      }).then(r => r.json()).then(data => this.renderEventsTable(data)).catch(err => console.error('Error loading events:', err));
    },
    renderDailyCharts: function (data) {
      // Render impressions chart
      this.renderStackedBarChart('cta-chart-impressions', data.dates, data.ctas, data.data, 'impression', 'Impressions');

      // Render clicks chart
      this.renderStackedBarChart('cta-chart-clicks', data.dates, data.ctas, data.data, 'click', 'Clicks');
    },
    renderStackedBarChart: function (canvasId, dates, ctas, data, eventType, title) {
      const ctx = document.getElementById(canvasId);
      if (!ctx) return;

      // Destroy existing chart if it exists
      if (this.charts[canvasId]) {
        this.charts[canvasId].destroy();
      }
      const chartCard = ctx.closest('.cta-chart-card');
      const chartContainer = chartCard?.querySelector('.cta-chart-container');
      const emptyStateContainer = chartCard?.querySelector('.cta-chart-empty-state');
      const legendContainer = chartCard?.querySelector('.cta-chart-legend');

      // Check if there's any data (with defensive checks for undefined)
      const hasData = ctas && dates && Object.keys(ctas).length > 0 && dates.length > 0;
      if (!hasData) {
        if (emptyStateContainer) {
          const icon = eventType === 'click' ? 'chart-bar' : 'visibility';
          emptyStateContainer.innerHTML = `<div class="cta-empty-state">
						<div class="cta-empty-state-icon">
							<span class="dashicons dashicons-${icon}"></span>
						</div>
						<div class="cta-empty-state-content">
							<h3 class="cta-empty-state-title">No ${eventType === 'click' ? 'Click' : 'Impression'} Data</h3>
							<p class="cta-empty-state-desc">Data will appear here once your CTAs receive traffic.</p>
						</div>
					</div>`;
          emptyStateContainer.style.display = '';
        }
        if (chartContainer) chartContainer.style.display = 'none';
        if (legendContainer) legendContainer.style.display = 'none';
        return;
      }

      // Show chart and hide empty state
      if (emptyStateContainer) {
        emptyStateContainer.style.display = 'none';
        emptyStateContainer.innerHTML = '';
      }
      if (chartContainer) chartContainer.style.display = '';
      if (legendContainer) legendContainer.style.display = '';
      const selectedCtaId = this.currentCtaId;
      const ctaList = selectedCtaId === 'all' ? Object.keys(ctas).map(id => parseInt(id)).sort((a, b) => a - b) : [parseInt(selectedCtaId)];
      const isStacked = selectedCtaId === 'all';

      // Build datasets
      const datasets = [];
      ctaList.forEach((ctaId, index) => {
        const cta = ctas[ctaId];
        if (!cta) return;
        const values = dates.map(date => {
          const events = data[date] || [];
          const eventData = events.find(e => parseInt(e.cta_id) === parseInt(ctaId) && e.event_type === eventType);
          return eventData ? parseInt(eventData.count) : 0;
        });
        datasets.push({
          label: cta.name || `CTA ${ctaId}`,
          data: values,
          backgroundColor: cta.color,
          borderColor: cta.color,
          borderWidth: 0,
          borderRadius: isStacked ? 0 : 4,
          ctaId: ctaId,
          ctaName: cta.name,
          ctaColor: cta.color
        });
      });
      const self = this;
      this.charts[canvasId] = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: dates.map(d => this.formatChartDate(d)),
          datasets: datasets
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              enabled: true,
              backgroundColor: '#1f2937',
              padding: 12,
              titleColor: '#fff',
              bodyColor: '#fff',
              borderColor: 'rgba(255,255,255,0.2)',
              borderWidth: 1,
              cornerRadius: 6,
              displayColors: false,
              callbacks: {
                title: context => {
                  const date = dates[context[0].dataIndex];
                  return `Date: ${this.formatDateDisplay(date)}`;
                },
                label: context => {
                  return `${context.dataset.label}: ${context.parsed.y}`;
                },
                afterLabel: context => {
                  const ctaId = context.dataset.ctaId;
                  return `CTA ID: ${ctaId}`;
                },
                labelColor: context => {
                  return {
                    backgroundColor: context.dataset.backgroundColor,
                    borderColor: context.dataset.borderColor
                  };
                }
              }
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              stacked: isStacked,
              ticks: {
                callback: function (value) {
                  return self.formatNumber(value);
                }
              }
            },
            x: {
              stacked: isStacked
            }
          },
          onHover: (event, activeElements) => {
            ctx.style.cursor = activeElements.length > 0 ? 'pointer' : 'default';
          }
        }
      });

      // Render legend
      const legendId = canvasId.replace('chart', 'legend');
      this.renderLegend(legendId, ctaList.map(id => ({
        label: ctas[id].name || `CTA ${id}`,
        color: ctas[id].color
      })));
    },
    /**
     * Helper method to show empty state for any chart
     */
    showChartEmptyState: function (canvasId, icon, title, description) {
      const ctx = document.getElementById(canvasId);
      if (!ctx) return;

      // Destroy existing chart if it exists
      if (this.charts[canvasId]) {
        this.charts[canvasId].destroy();
        delete this.charts[canvasId];
      }
      const chartCard = ctx.closest('.cta-chart-card');
      const chartContainer = chartCard?.querySelector('.cta-chart-container');
      const emptyStateContainer = chartCard?.querySelector('.cta-chart-empty-state');
      const legendContainer = chartCard?.querySelector('.cta-chart-legend');
      if (emptyStateContainer) {
        emptyStateContainer.innerHTML = `<div class="cta-empty-state">
					<div class="cta-empty-state-icon">
						<span class="dashicons dashicons-${icon}"></span>
					</div>
					<div class="cta-empty-state-content">
						<h3 class="cta-empty-state-title">${title}</h3>
						<p class="cta-empty-state-desc">${description}</p>
					</div>
				</div>`;
        emptyStateContainer.style.display = '';
      }
      if (chartContainer) chartContainer.style.display = 'none';
      if (legendContainer) legendContainer.style.display = 'none';
    },
    renderTypeCharts: function (data) {
      const typeColors = {
        phone: '#8b5cf6',
        link: '#06b6d4',
        email: '#f59e0b',
        popup: '#14b8a6'
      };

      // Defensive check for missing or empty data
      if (!data || !data.by_type || !data.dates || Object.keys(data.by_type).length === 0 || data.dates.length === 0) {
        this.showChartEmptyState('cta-chart-impressions-type', 'chart-pie', 'No Type Data', 'CTA type breakdown will appear here once you have traffic.');
        this.showChartEmptyState('cta-chart-clicks-type', 'chart-pie', 'No Type Data', 'CTA type breakdown will appear here once you have traffic.');
        this.renderLegend('cta-legend-impressions-type', []);
        this.renderLegend('cta-legend-clicks-type', []);
        return;
      }

      // Prepare datasets by type - for impressions
      const imprDatasets = [];
      Object.keys(data.by_type).forEach(type => {
        const values = data.dates.map(date => data.by_type[type][date] || 0);
        imprDatasets.push({
          label: type.charAt(0).toUpperCase() + type.slice(1),
          data: values,
          backgroundColor: typeColors[type] || '#6b7280',
          borderColor: typeColors[type] || '#6b7280',
          borderWidth: 0,
          borderRadius: 0,
          type: type
        });
      });

      // Impressions by type
      this.renderTypeChart('cta-chart-impressions-type', data.dates, imprDatasets);

      // For now, render clicks by type with same data (API can be enhanced to return separate click data)
      const clickDatasets = imprDatasets.map(dataset => ({
        ...dataset
      }));
      this.renderTypeChart('cta-chart-clicks-type', data.dates, clickDatasets);

      // Render legend
      const legendItems = Object.keys(data.by_type).map(type => ({
        label: type.charAt(0).toUpperCase() + type.slice(1),
        color: typeColors[type] || '#6b7280'
      }));
      this.renderLegend('cta-legend-impressions-type', legendItems);
      this.renderLegend('cta-legend-clicks-type', legendItems);
    },
    renderTypeChart: function (canvasId, dates, datasets) {
      const ctx = document.getElementById(canvasId);
      if (!ctx) return;
      if (this.charts[canvasId]) {
        this.charts[canvasId].destroy();
      }
      const chartCard = ctx.closest('.cta-chart-card');
      const chartContainer = chartCard?.querySelector('.cta-chart-container');
      const emptyStateContainer = chartCard?.querySelector('.cta-chart-empty-state');
      const legendContainer = chartCard?.querySelector('.cta-chart-legend');

      // Check if there's any data
      const hasData = datasets.length > 0 && dates.length > 0;
      if (!hasData) {
        if (emptyStateContainer) {
          emptyStateContainer.innerHTML = `<div class="cta-empty-state">
						<div class="cta-empty-state-icon">
							<span class="dashicons dashicons-chart-pie"></span>
						</div>
						<div class="cta-empty-state-content">
							<h3 class="cta-empty-state-title">No Type Data</h3>
							<p class="cta-empty-state-desc">CTA type breakdown will appear here once you have traffic.</p>
						</div>
					</div>`;
          emptyStateContainer.style.display = '';
        }
        if (chartContainer) chartContainer.style.display = 'none';
        if (legendContainer) legendContainer.style.display = 'none';
        return;
      }

      // Show chart and hide empty state
      if (emptyStateContainer) {
        emptyStateContainer.style.display = 'none';
        emptyStateContainer.innerHTML = '';
      }
      if (chartContainer) chartContainer.style.display = '';
      if (legendContainer) legendContainer.style.display = '';
      const self = this;
      this.charts[canvasId] = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: dates.map(d => this.formatChartDate(d)),
          datasets: datasets
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              enabled: true,
              backgroundColor: '#1f2937',
              padding: 12,
              borderRadius: 6,
              displayColors: false,
              callbacks: {
                label: context => {
                  return `${context.dataset.label}: ${context.parsed.y}`;
                },
                labelColor: context => {
                  return {
                    backgroundColor: context.dataset.backgroundColor
                  };
                }
              }
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              stacked: true,
              ticks: {
                callback: function (value) {
                  return self.formatNumber(value);
                }
              }
            },
            x: {
              stacked: true
            }
          }
        }
      });
    },
    renderTopCtasChart: function (data) {
      const canvasId = 'cta-chart-top-ctas';
      const ctx = document.getElementById(canvasId);
      if (!ctx) return;
      if (this.charts[canvasId]) {
        this.charts[canvasId].destroy();
      }
      const chartCard = ctx.closest('.cta-chart-card');
      const chartContainer = chartCard?.querySelector('.cta-chart-container');
      const emptyStateContainer = chartCard?.querySelector('.cta-chart-empty-state');
      const legendContainer = chartCard?.querySelector('.cta-chart-legend');

      // Check if there's any data
      const hasData = data && data.length > 0;
      if (!hasData) {
        if (emptyStateContainer) {
          emptyStateContainer.innerHTML = `<div class="cta-empty-state">
						<div class="cta-empty-state-icon">
							<span class="dashicons dashicons-awards"></span>
						</div>
						<div class="cta-empty-state-content">
							<h3 class="cta-empty-state-title">No Top CTAs Yet</h3>
							<p class="cta-empty-state-desc">Top performing CTAs will appear here once you have traffic.</p>
						</div>
					</div>`;
          emptyStateContainer.style.display = '';
        }
        if (chartContainer) chartContainer.style.display = 'none';
        if (legendContainer) legendContainer.style.display = 'none';
        return;
      }

      // Show chart and hide empty state
      if (emptyStateContainer) {
        emptyStateContainer.style.display = 'none';
        emptyStateContainer.innerHTML = '';
      }
      if (chartContainer) chartContainer.style.display = '';
      if (legendContainer) legendContainer.style.display = '';
      const self = this;
      const colors = data.map(cta => cta.color);
      const ctaNames = data.map(cta => cta.name || `CTA ${cta.id}`);
      const clicks = data.map(cta => cta.clicks);
      this.charts[canvasId] = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: ctaNames,
          datasets: [{
            label: 'Clicks',
            data: clicks,
            backgroundColor: colors,
            borderColor: colors,
            borderWidth: 0,
            borderRadius: 4,
            ctaData: data
          }]
        },
        options: {
          indexAxis: 'y',
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              enabled: true,
              backgroundColor: '#1f2937',
              padding: 12,
              borderRadius: 6,
              displayColors: false,
              callbacks: {
                label: context => {
                  const cta = data[context.dataIndex];
                  const ctr = cta.impressions > 0 ? (cta.clicks / cta.impressions * 100).toFixed(2) : '0.00';
                  return `Clicks: ${self.formatNumber(cta.clicks)} | CTR: ${ctr}%`;
                },
                labelColor: context => {
                  return {
                    backgroundColor: colors[context.dataIndex]
                  };
                }
              }
            }
          },
          scales: {
            x: {
              beginAtZero: true,
              ticks: {
                callback: function (value) {
                  return self.formatNumber(value);
                }
              }
            }
          }
        }
      });

      // Render legend
      const legendItems = data.map(cta => ({
        label: cta.name || `CTA ${cta.id}`,
        color: cta.color
      }));
      this.renderLegend('cta-legend-top-ctas', legendItems);
    },
    renderLegend: function (elementId, items) {
      const container = document.getElementById(elementId);
      if (!container) return;
      container.innerHTML = items.map(item => `
				<div style="display: inline-flex; align-items: center; margin-right: 20px; margin-bottom: 8px; font-size: 13px; color: #6b7280;">
					<span style="width: 12px; height: 12px; background-color: ${item.color}; border-radius: 2px; margin-right: 8px; flex-shrink: 0;"></span>
					<span>${item.label}</span>
				</div>
			`).join('');
    },
    // ==========================================
    // NEW WIDGETS - Daily CTR Trend Line Chart
    // ==========================================
    renderCTRTrendChart: function (data) {
      const canvasId = 'cta-chart-ctr-trend';
      const ctx = document.getElementById(canvasId);
      if (!ctx) return;
      if (this.charts[canvasId]) {
        this.charts[canvasId].destroy();
      }
      const chartCard = ctx.closest('.cta-chart-card');
      const chartContainer = chartCard?.querySelector('.cta-chart-container');
      const emptyStateContainer = chartCard?.querySelector('.cta-chart-empty-state');
      const legendContainer = chartCard?.querySelector('.cta-chart-legend');
      const self = this;
      const dates = data?.dates || [];
      const ctas = data?.ctas || {};
      const dailyData = data?.data || {};

      // Check if there's any actual data with events
      const hasData = dates.length > 0 && Object.keys(dailyData).length > 0 && Object.values(dailyData).some(events => Array.isArray(events) && events.length > 0);
      if (!hasData) {
        if (emptyStateContainer) {
          emptyStateContainer.innerHTML = `<div class="cta-empty-state">
						<div class="cta-empty-state-icon">
							<span class="dashicons dashicons-chart-line"></span>
						</div>
						<div class="cta-empty-state-content">
							<h3 class="cta-empty-state-title">No CTR Data</h3>
							<p class="cta-empty-state-desc">Click-through rate trends will appear here once you have traffic.</p>
						</div>
					</div>`;
          emptyStateContainer.style.display = '';
        }
        if (chartContainer) chartContainer.style.display = 'none';
        if (legendContainer) legendContainer.style.display = 'none';
        return;
      }

      // Show chart and hide empty state
      if (emptyStateContainer) {
        emptyStateContainer.style.display = 'none';
        emptyStateContainer.innerHTML = '';
      }
      if (chartContainer) chartContainer.style.display = '';
      if (legendContainer) legendContainer.style.display = '';

      // Calculate CTR per day
      const ctrValues = dates.map(date => {
        const events = dailyData[date] || [];
        let dayImpressions = 0;
        let dayClicks = 0;
        events.forEach(event => {
          if (event.event_type === 'impression') {
            dayImpressions += parseInt(event.count);
          } else if (event.event_type === 'click') {
            dayClicks += parseInt(event.count);
          }
        });
        return dayImpressions > 0 ? dayClicks / dayImpressions * 100 : 0;
      });

      // Get color based on filter
      let lineColor = '#3b82f6';
      if (this.currentCtaId !== 'all' && ctas[this.currentCtaId]) {
        lineColor = ctas[this.currentCtaId].color || '#3b82f6';
      }
      this.charts[canvasId] = new Chart(ctx, {
        type: 'line',
        data: {
          labels: dates.map(d => this.formatChartDate(d)),
          datasets: [{
            label: 'CTR %',
            data: ctrValues,
            borderColor: lineColor,
            backgroundColor: lineColor + '20',
            fill: true,
            tension: 0.3,
            pointRadius: 4,
            pointHoverRadius: 6,
            pointBackgroundColor: lineColor,
            pointBorderColor: '#fff',
            pointBorderWidth: 2
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              enabled: true,
              backgroundColor: '#1f2937',
              padding: 12,
              borderRadius: 6,
              displayColors: false,
              callbacks: {
                title: context => {
                  const dateIdx = context[0].dataIndex;
                  return `Date: ${this.formatDateDisplay(dates[dateIdx])}`;
                },
                label: context => {
                  const ctr = context.parsed.y.toFixed(2);
                  return `CTR: ${ctr}%`;
                },
                afterLabel: context => {
                  const dateIdx = context.dataIndex;
                  const events = dailyData[dates[dateIdx]] || [];
                  let impr = 0,
                    clicks = 0;
                  events.forEach(e => {
                    if (e.event_type === 'impression') impr += parseInt(e.count);
                    if (e.event_type === 'click') clicks += parseInt(e.count);
                  });
                  return `Clicks: ${self.formatNumber(clicks)} | Impressions: ${self.formatNumber(impr)}`;
                }
              }
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              ticks: {
                callback: function (value) {
                  return value.toFixed(1) + '%';
                }
              }
            }
          }
        }
      });

      // Render legend
      const ctaLabel = this.currentCtaId === 'all' ? 'Overall CTR' : ctas[this.currentCtaId]?.name || 'CTR';
      this.renderLegend('cta-legend-ctr-trend', [{
        label: ctaLabel,
        color: lineColor
      }]);
    },
    // ==========================================
    // NEW WIDGETS - Impressions Share Donut Chart
    // ==========================================
    renderImpressionsShareChart: function (data) {
      const canvasId = 'cta-chart-impressions-share';
      const cardId = 'cta-card-impressions-share';
      const ctx = document.getElementById(canvasId);
      const card = document.getElementById(cardId);
      if (!ctx || !card) return;

      // Hide chart if single CTA is selected
      if (this.currentCtaId !== 'all') {
        card.style.display = 'none';
        return;
      }
      card.style.display = '';
      if (this.charts[canvasId]) {
        this.charts[canvasId].destroy();
      }
      const chartContainer = card.querySelector('.cta-chart-container');
      const emptyStateContainer = card.querySelector('.cta-chart-empty-state');
      const legendContainer = card.querySelector('.cta-chart-legend');

      // Check if there's any data
      const hasData = data && data.length > 0;
      if (!hasData) {
        if (emptyStateContainer) {
          emptyStateContainer.innerHTML = `<div class="cta-empty-state">
						<div class="cta-empty-state-icon">
							<span class="dashicons dashicons-visibility"></span>
						</div>
						<div class="cta-empty-state-content">
							<h3 class="cta-empty-state-title">No Impressions</h3>
							<p class="cta-empty-state-desc">Impression share data will appear here.</p>
						</div>
					</div>`;
          emptyStateContainer.style.display = '';
        }
        if (chartContainer) chartContainer.style.display = 'none';
        if (legendContainer) legendContainer.style.display = 'none';
        return;
      }

      // Show chart and hide empty state
      if (emptyStateContainer) {
        emptyStateContainer.style.display = 'none';
        emptyStateContainer.innerHTML = '';
      }
      if (chartContainer) chartContainer.style.display = '';
      if (legendContainer) legendContainer.style.display = '';
      const self = this;
      const labels = data.map(cta => cta.name || `CTA ${cta.id}`);
      const values = data.map(cta => cta.impressions);
      const colors = data.map(cta => cta.color || '#3b82f6');
      const totalImpressions = values.reduce((a, b) => a + b, 0);
      this.charts[canvasId] = new Chart(ctx, {
        type: 'doughnut',
        data: {
          labels: labels,
          datasets: [{
            data: values,
            backgroundColor: colors,
            borderColor: '#fff',
            borderWidth: 2,
            ctaData: data
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          cutout: '60%',
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              enabled: true,
              backgroundColor: '#1f2937',
              padding: 12,
              borderRadius: 6,
              displayColors: false,
              callbacks: {
                title: context => {
                  const cta = data[context[0].dataIndex];
                  return cta.name || `CTA ${cta.id}`;
                },
                label: context => {
                  const cta = data[context.dataIndex];
                  const pct = totalImpressions > 0 ? (cta.impressions / totalImpressions * 100).toFixed(1) : 0;
                  return `Impressions: ${self.formatNumber(cta.impressions)} (${pct}%)`;
                },
                afterLabel: context => {
                  const cta = data[context.dataIndex];
                  return `CTA ID: ${cta.id}`;
                },
                labelColor: context => {
                  return {
                    backgroundColor: colors[context.dataIndex]
                  };
                }
              }
            }
          }
        }
      });

      // Render legend
      const legendItems = data.map(cta => ({
        label: cta.name || `CTA ${cta.id}`,
        color: cta.color || '#3b82f6'
      }));
      this.renderLegend('cta-legend-impressions-share', legendItems);
    },
    // ==========================================
    // NEW WIDGETS - Clicks Share Donut Chart
    // ==========================================
    renderClicksShareChart: function (data) {
      const canvasId = 'cta-chart-clicks-share';
      const cardId = 'cta-card-clicks-share';
      const ctx = document.getElementById(canvasId);
      const card = document.getElementById(cardId);
      if (!ctx || !card) return;

      // Hide chart if single CTA is selected
      if (this.currentCtaId !== 'all') {
        card.style.display = 'none';
        return;
      }
      card.style.display = '';
      if (this.charts[canvasId]) {
        this.charts[canvasId].destroy();
      }
      const chartContainer = card.querySelector('.cta-chart-container');
      const emptyStateContainer = card.querySelector('.cta-chart-empty-state');
      const legendContainer = card.querySelector('.cta-chart-legend');

      // Check if there's any data
      const hasData = data && data.length > 0;
      if (!hasData) {
        if (emptyStateContainer) {
          emptyStateContainer.innerHTML = `<div class="cta-empty-state">
						<div class="cta-empty-state-icon">
							<span class="dashicons dashicons-chart-bar"></span>
						</div>
						<div class="cta-empty-state-content">
							<h3 class="cta-empty-state-title">No Clicks</h3>
							<p class="cta-empty-state-desc">Click share data will appear here.</p>
						</div>
					</div>`;
          emptyStateContainer.style.display = '';
        }
        if (chartContainer) chartContainer.style.display = 'none';
        if (legendContainer) legendContainer.style.display = 'none';
        return;
      }

      // Show chart and hide empty state
      if (emptyStateContainer) {
        emptyStateContainer.style.display = 'none';
        emptyStateContainer.innerHTML = '';
      }
      if (chartContainer) chartContainer.style.display = '';
      if (legendContainer) legendContainer.style.display = '';
      const self = this;
      const labels = data.map(cta => cta.name || `CTA ${cta.id}`);
      const values = data.map(cta => cta.clicks);
      const colors = data.map(cta => cta.color || '#3b82f6');
      const totalClicks = values.reduce((a, b) => a + b, 0);
      this.charts[canvasId] = new Chart(ctx, {
        type: 'doughnut',
        data: {
          labels: labels,
          datasets: [{
            data: values,
            backgroundColor: colors,
            borderColor: '#fff',
            borderWidth: 2,
            ctaData: data
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          cutout: '60%',
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              enabled: true,
              backgroundColor: '#1f2937',
              padding: 12,
              borderRadius: 6,
              displayColors: false,
              callbacks: {
                title: context => {
                  const cta = data[context[0].dataIndex];
                  return cta.name || `CTA ${cta.id}`;
                },
                label: context => {
                  const cta = data[context.dataIndex];
                  const pct = totalClicks > 0 ? (cta.clicks / totalClicks * 100).toFixed(1) : 0;
                  return `Clicks: ${self.formatNumber(cta.clicks)} (${pct}%)`;
                },
                afterLabel: context => {
                  const cta = data[context.dataIndex];
                  return `CTA ID: ${cta.id}`;
                },
                labelColor: context => {
                  return {
                    backgroundColor: colors[context.dataIndex]
                  };
                }
              }
            }
          }
        }
      });

      // Render legend
      const legendItems = data.map(cta => ({
        label: cta.name || `CTA ${cta.id}`,
        color: cta.color || '#3b82f6'
      }));
      this.renderLegend('cta-legend-clicks-share', legendItems);
    },
    // ==========================================
    // NEW WIDGETS - Top Pages by Clicks
    // ==========================================
    fetchTopPagesByClicks: function () {
      return fetch(`${ctaAnalyticsData.ajaxUrl}?action=rest_route&route=/cta-analytics/v1/top-pages&start_date=${this.currentDateStart}&end_date=${this.currentDateEnd}&cta_id=${this.currentCtaId}&sort_by=clicks&page=${this.topPagesClicksPage}&per_page=10`, {
        credentials: 'same-origin'
      }).then(r => r.json()).then(data => {
        this.topPagesClicksHasData = data.pages && data.pages.length > 0;
        this.renderTopPagesTable(data, 'clicks');
        this.updateTopPagesSection();
      }).catch(err => {
        console.error('Error fetching top pages by clicks:', err);
        this.topPagesClicksHasData = false;
        this.updateTopPagesSection();
      });
    },
    // ==========================================
    // NEW WIDGETS - Top Pages by Impressions
    // ==========================================
    fetchTopPagesByImpressions: function () {
      return fetch(`${ctaAnalyticsData.ajaxUrl}?action=rest_route&route=/cta-analytics/v1/top-pages&start_date=${this.currentDateStart}&end_date=${this.currentDateEnd}&cta_id=${this.currentCtaId}&sort_by=impressions&page=${this.topPagesImpressionsPage}&per_page=10`, {
        credentials: 'same-origin'
      }).then(r => r.json()).then(data => {
        this.topPagesImpressionsHasData = data.pages && data.pages.length > 0;
        this.renderTopPagesTable(data, 'impressions');
        this.updateTopPagesSection();
      }).catch(err => {
        console.error('Error fetching top pages by impressions:', err);
        this.topPagesImpressionsHasData = false;
        this.updateTopPagesSection();
      });
    },
    /**
     * Update the Top Pages section based on data availability
     * Shows a single empty state if both tables have no data
     */
    updateTopPagesSection: function () {
      // Wait until both requests have completed
      if (this.topPagesClicksHasData === null || this.topPagesImpressionsHasData === null) {
        return;
      }
      const sectionEmptyState = document.getElementById('cta-top-pages-empty-state');
      const tablesContainer = document.getElementById('cta-top-pages-tables');
      if (!sectionEmptyState || !tablesContainer) return;
      const bothEmpty = !this.topPagesClicksHasData && !this.topPagesImpressionsHasData;
      if (bothEmpty) {
        // Show section-level empty state, hide individual tables
        sectionEmptyState.style.display = '';
        tablesContainer.style.display = 'none';
      } else {
        // Show tables container, hide section-level empty state
        sectionEmptyState.style.display = 'none';
        tablesContainer.style.display = '';
      }
    },
    renderTopPagesTable: function (data, sortBy) {
      const listId = sortBy === 'clicks' ? 'cta-top-pages-clicks-list' : 'cta-top-pages-impressions-list';
      const paginationId = sortBy === 'clicks' ? 'cta-pagination-pages-clicks' : 'cta-pagination-pages-impressions';
      const list = document.getElementById(listId);
      if (!list) return;
      if (!data.pages || data.pages.length === 0) {
        const icon = sortBy === 'clicks' ? 'chart-bar' : 'visibility';
        const title = sortBy === 'clicks' ? 'No Click Data' : 'No Impression Data';
        list.innerHTML = `<div class="cta-top-pages-empty">
					<div class="cta-empty-state">
						<div class="cta-empty-state-icon">
							<span class="dashicons dashicons-${icon}"></span>
						</div>
						<div class="cta-empty-state-content">
							<h3 class="cta-empty-state-title">${title}</h3>
							<p class="cta-empty-state-desc">Page analytics will appear here once your CTAs receive traffic.</p>
						</div>
					</div>
				</div>`;
        document.getElementById(paginationId).innerHTML = '';
        return;
      }
      const metricLabels = {
        clicks: list.dataset.labelClicks || 'Clicks',
        impressions: list.dataset.labelImpressions || 'Impressions',
        ctr: list.dataset.labelCtr || 'CTR'
      };
      const rowsHtml = data.pages.map(page => {
        const displayUrl = this.truncateUrl(page.page_url);
        const primaryMetrics = sortBy === 'clicks' ? `<div class="cta-top-page-row__stat"><span class="cta-top-page-row__label">${metricLabels.clicks}</span><span>${this.formatNumber(page.clicks)}</span></div><div class="cta-top-page-row__stat"><span class="cta-top-page-row__label">${metricLabels.impressions}</span><span>${this.formatNumber(page.impressions)}</span></div>` : `<div class="cta-top-page-row__stat"><span class="cta-top-page-row__label">${metricLabels.impressions}</span><span>${this.formatNumber(page.impressions)}</span></div><div class="cta-top-page-row__stat"><span class="cta-top-page-row__label">${metricLabels.clicks}</span><span>${this.formatNumber(page.clicks)}</span></div>`;
        return `
					<article class="cta-top-page-row">
						<div class="cta-top-page-row__title">
							<a href="${this.escapeHtml(page.page_url)}" target="_blank" rel="noopener noreferrer" title="${this.escapeHtml(page.page_url)}">
								${displayUrl}
							</a>
						</div>
						<div class="cta-top-page-row__metrics">
							${primaryMetrics}
						</div>
						<div class="cta-top-page-row__ctr">
							<span class="cta-top-page-row__label">${metricLabels.ctr}</span>
							<span>${page.ctr}%</span>
						</div>
					</article>
				`;
      }).join('');
      list.innerHTML = rowsHtml;
      this.renderTopPagesPagination(data, sortBy);
    },
    renderTopPagesPagination: function (data, sortBy) {
      const paginationId = sortBy === 'clicks' ? 'cta-pagination-pages-clicks' : 'cta-pagination-pages-impressions';
      const container = document.getElementById(paginationId);
      if (!container) return;
      if (data.total_pages <= 1) {
        container.innerHTML = '';
        return;
      }
      const currentPage = sortBy === 'clicks' ? this.topPagesClicksPage : this.topPagesImpressionsPage;
      let html = '<div class="cta-pagination-controls">';

      // Previous button
      if (currentPage > 1) {
        html += `<button class="button" onclick="window.Analytics.changeTopPagesPage(${currentPage - 1}, '${sortBy}')">← Prev</button>`;
      }

      // Page numbers
      const maxPages = Math.min(data.total_pages, 5);
      let startPage = Math.max(1, currentPage - 2);
      let endPage = Math.min(data.total_pages, startPage + 4);
      if (endPage - startPage < 4) {
        startPage = Math.max(1, endPage - 4);
      }
      if (startPage > 1) {
        html += `<button class="button" onclick="window.Analytics.changeTopPagesPage(1, '${sortBy}')">1</button>`;
        if (startPage > 2) {
          html += `<span class="cta-pagination-dots">…</span>`;
        }
      }
      for (let i = startPage; i <= endPage; i++) {
        if (i === currentPage) {
          html += `<span class="cta-pagination-current">${i}</span>`;
        } else {
          html += `<button class="button" onclick="window.Analytics.changeTopPagesPage(${i}, '${sortBy}')">${i}</button>`;
        }
      }
      if (endPage < data.total_pages) {
        if (endPage < data.total_pages - 1) {
          html += `<span class="cta-pagination-dots">…</span>`;
        }
        html += `<button class="button" onclick="window.Analytics.changeTopPagesPage(${data.total_pages}, '${sortBy}')">${data.total_pages}</button>`;
      }

      // Next button
      if (currentPage < data.total_pages) {
        html += `<button class="button" onclick="window.Analytics.changeTopPagesPage(${currentPage + 1}, '${sortBy}')">Next →</button>`;
      }
      html += '</div>';
      container.innerHTML = html;
    },
    changeTopPagesPage: function (page, sortBy) {
      if (sortBy === 'clicks') {
        this.topPagesClicksPage = page;
        this.fetchTopPagesByClicks();
      } else {
        this.topPagesImpressionsPage = page;
        this.fetchTopPagesByImpressions();
      }
    },
    updateKPIs: function (data) {
      if (!data || typeof data !== 'object' || !data.data || typeof data.data !== 'object') {
        this.setKpiContent(0, 0, '0.00');
        return;
      }
      let totalImpressions = 0;
      let totalClicks = 0;
      Object.keys(data.data).forEach(date => {
        const events = data.data[date];
        if (!Array.isArray(events)) {
          return;
        }
        events.forEach(event => {
          if (event.event_type === 'impression') {
            totalImpressions += parseInt(event.count, 10) || 0;
          } else if (event.event_type === 'click') {
            totalClicks += parseInt(event.count, 10) || 0;
          }
        });
      });
      const ctr = totalImpressions > 0 ? (totalClicks / totalImpressions * 100).toFixed(2) : '0.00';
      this.setKpiContent(totalImpressions, totalClicks, ctr);
    },
    setKpiContent: function (impressions, clicks, ctr) {
      const impressionsEl = document.getElementById('cta-kpi-impressions');
      const clicksEl = document.getElementById('cta-kpi-clicks');
      const ctrEl = document.getElementById('cta-kpi-ctr');
      if (impressionsEl) {
        impressionsEl.textContent = this.formatNumber(impressions);
      }
      if (clicksEl) {
        clicksEl.textContent = this.formatNumber(clicks);
      }
      if (ctrEl) {
        ctrEl.textContent = `${ctr}%`;
      }
    },
    renderEventsTable: function (data) {
      const listInner = document.getElementById('cta-events-list-inner');
      if (!listInner) return;
      const eventsCard = document.getElementById('cta-events-card');
      const emptyStateContainer = document.getElementById('cta-events-empty-state');
      if (!data.events || data.events.length === 0) {
        if (emptyStateContainer) {
          emptyStateContainer.style.display = '';
        }
        if (eventsCard) eventsCard.style.display = 'none';
        listInner.innerHTML = '';
        this.renderPagination(data);
        return;
      }

      // Show card, hide empty state
      if (emptyStateContainer) {
        emptyStateContainer.style.display = 'none';
      }
      if (eventsCard) eventsCard.style.display = '';
      const buildLink = url => {
        if (!url) {
          return '—';
        }
        const escaped = this.escapeHtml(url);
        return `<a href="${escaped}" target="_blank" rel="noopener noreferrer" title="${escaped}">${this.truncateUrl(url)}</a>`;
      };
      listInner.innerHTML = data.events.map(event => {
        const eventLabel = event.event_type === 'click' ? '<span class="cta-event-badge cta-event-click">Click</span>' : '<span class="cta-event-badge cta-event-impression">Impression</span>';
        const ctaTitle = event.cta_title || (event.cta_id ? `CTA ${event.cta_id}` : 'CTA');
        const metaItems = [{
          label: 'Page URL',
          value: buildLink(event.page_url)
        }, {
          label: 'Referrer',
          value: buildLink(event.referrer)
        }, {
          label: 'Device',
          value: this.escapeHtml(event.device || '—')
        }];
        if (ctaAnalyticsData.isPro) {
          const ipAddress = this.escapeHtml(event.ip_address || '—');
          const rawUserAgent = event.user_agent || '';
          const truncatedUserAgent = rawUserAgent.length > 60 ? `${rawUserAgent.substring(0, 60)}…` : rawUserAgent;
          const userAgentValue = truncatedUserAgent ? this.escapeHtml(truncatedUserAgent) : '—';
          metaItems.push({
            label: 'IP Address',
            value: ipAddress
          }, {
            label: 'User Agent',
            value: userAgentValue
          });
        }
        const metaHtml = metaItems.map(item => `
					<div class="cta-event-row__meta-item">
						<span class="cta-event-row__meta-label">${item.label}</span>
						<span class="cta-event-row__meta-value">${item.value}</span>
					</div>
				`).join('');
        return `
					<article class="cta-event-row">
						<div class="cta-event-row__header">
							<span class="cta-event-row__time">${this.formatDateTime(event.created_at)}</span>
							${eventLabel}
						</div>
						<p class="cta-event-row__cta-name">${this.escapeHtml(ctaTitle)}</p>
						<div class="cta-event-row__meta">${metaHtml}</div>
					</article>
				`;
      }).join('');
      this.renderPagination(data);
    },
    renderPagination: function (data) {
      const container = document.getElementById('cta-pagination');
      if (!container) return;
      if (data.total_pages <= 1) {
        container.innerHTML = '';
        return;
      }
      let html = '<div class="cta-pagination-controls">';

      // Previous button
      if (this.eventPage > 1) {
        html += `<button class="button" onclick="window.Analytics.changePage(${this.eventPage - 1})">← Previous</button>`;
      }

      // Page numbers
      const maxPages = Math.min(data.total_pages, 7);
      let startPage = Math.max(1, this.eventPage - 3);
      let endPage = Math.min(data.total_pages, startPage + 6);
      if (endPage - startPage < 6) {
        startPage = Math.max(1, endPage - 6);
      }
      if (startPage > 1) {
        html += `<button class="button" onclick="window.Analytics.changePage(1)">1</button>`;
        if (startPage > 2) {
          html += `<span class="cta-pagination-dots">…</span>`;
        }
      }
      for (let i = startPage; i <= endPage; i++) {
        if (i === this.eventPage) {
          html += `<span class="cta-pagination-current">${i}</span>`;
        } else {
          html += `<button class="button" onclick="window.Analytics.changePage(${i})">${i}</button>`;
        }
      }
      if (endPage < data.total_pages) {
        if (endPage < data.total_pages - 1) {
          html += `<span class="cta-pagination-dots">…</span>`;
        }
        html += `<button class="button" onclick="window.Analytics.changePage(${data.total_pages})">${data.total_pages}</button>`;
      }

      // Next button
      if (this.eventPage < data.total_pages) {
        html += `<button class="button" onclick="window.Analytics.changePage(${this.eventPage + 1})">Next →</button>`;
      }
      html += `</div>`;
      container.innerHTML = html;
    },
    changePage: function (page) {
      this.eventPage = page;
      this.loadEvents();
      const tableSection = document.querySelector('.cta-table-section');
      if (tableSection) {
        tableSection.scrollIntoView({
          behavior: 'smooth'
        });
      }
    },
    initPerformanceList: function () {
      const container = document.getElementById('cta-performance-list');
      if (!container) {
        return;
      }
      const rowsAttr = container.getAttribute('data-performance-rows');
      if (!rowsAttr) {
        return;
      }
      let rows = [];
      try {
        rows = JSON.parse(rowsAttr);
      } catch (error) {
        console.error('CTA Performance: failed to parse rows data', error);
        rows = [];
      }
      if (!rows.length) {
        return;
      }
      const listBody = container.querySelector('#cta-performance-list-body');
      const pagination = container.querySelector('#cta-performance-pagination');
      const perPageSelect = container.querySelector('#cta-performance-per-page');
      const sortButtons = container.querySelectorAll('.cta-performance-sort-btn');
      if (!listBody || !pagination || !perPageSelect || !sortButtons.length) {
        return;
      }
      this.performanceState = {
        rows,
        sortKey: 'clicks',
        sortDir: 'desc',
        page: 1,
        perPage: parseInt(perPageSelect.value, 10) || 25,
        container,
        listBody,
        pagination,
        perPageSelect,
        sortButtons,
        labels: {
          impressions: container.dataset.labelImpressions || 'Impressions',
          clicks: container.dataset.labelClicks || 'Clicks',
          ctr: container.dataset.labelCtr || 'CTR',
          topPage: container.dataset.labelTopPage || 'Top Page:'
        }
      };
      sortButtons.forEach(btn => {
        btn.addEventListener('click', () => {
          const key = btn.getAttribute('data-sort-key');
          const defaultDir = btn.getAttribute('data-default-dir') || 'desc';
          if (!key) {
            return;
          }
          if (this.performanceState.sortKey === key) {
            this.performanceState.sortDir = this.performanceState.sortDir === 'asc' ? 'desc' : 'asc';
          } else {
            this.performanceState.sortKey = key;
            this.performanceState.sortDir = defaultDir;
          }
          this.performanceState.page = 1;
          this.setPerformanceSortState();
          this.renderPerformanceList();
        });
      });
      perPageSelect.addEventListener('change', () => {
        this.performanceState.perPage = parseInt(perPageSelect.value, 10) || 25;
        this.performanceState.page = 1;
        this.renderPerformanceList();
      });
      this.setPerformanceSortState();
      this.renderPerformanceList();
    },
    getSortedPerformanceRows: function () {
      const state = this.performanceState;
      if (!state) {
        return [];
      }
      return state.rows.slice().sort((a, b) => {
        const key = state.sortKey;
        let valueA = a[key];
        let valueB = b[key];
        if (typeof valueA === 'string') {
          valueA = valueA.toLowerCase();
          valueB = (valueB || '').toLowerCase();
        }
        if (valueA > valueB) {
          return state.sortDir === 'asc' ? 1 : -1;
        }
        if (valueA < valueB) {
          return state.sortDir === 'asc' ? -1 : 1;
        }
        return 0;
      });
    },
    renderPerformanceList: function () {
      const state = this.performanceState;
      if (!state) {
        return;
      }
      const sortedRows = this.getSortedPerformanceRows();
      const totalPages = Math.max(1, Math.ceil(sortedRows.length / state.perPage));
      if (state.page > totalPages) {
        state.page = totalPages;
      }
      const start = (state.page - 1) * state.perPage;
      const pagedRows = sortedRows.slice(start, start + state.perPage);
      state.listBody.innerHTML = pagedRows.map(row => this.buildPerformanceRow(row)).join('');
      this.renderPerformancePagination(totalPages);
    },
    buildPerformanceRow: function (row) {
      const state = this.performanceState;
      if (!state) {
        return '';
      }
      const topPage = row.top_page && row.top_page !== '—' ? row.top_page : '—';
      const ctr = Number(row.ctr) || 0;
      return `
				<article class="cta-performance-row" data-cta-title="${this.escapeHtml(row.cta_title)}" data-clicks="${this.escapeHtml(row.clicks)}" data-impressions="${this.escapeHtml(row.impressions)}" data-ctr="${this.escapeHtml(ctr)}">
					<div class="cta-performance-row__heading">
						<span class="cta-performance-row__name">${this.escapeHtml(row.cta_title)}</span>
						<span class="cta-performance-row__top-page">${state.labels.topPage} ${this.escapeHtml(topPage)}</span>
					</div>
					<div class="cta-performance-row__metrics">
						<div class="cta-performance-metric">
							<span class="cta-performance-metric__label">${state.labels.impressions}</span>
							<span class="cta-performance-metric__value">${this.formatNumber(row.impressions)}</span>
						</div>
						<div class="cta-performance-metric">
							<span class="cta-performance-metric__label">${state.labels.clicks}</span>
							<span class="cta-performance-metric__value">${this.formatNumber(row.clicks)}</span>
						</div>
						<div class="cta-performance-metric">
							<span class="cta-performance-metric__label">${state.labels.ctr}</span>
							<span class="cta-performance-metric__value">${this.escapeHtml(ctr)}%</span>
						</div>
					</div>
				</article>
			`;
    },
    renderPerformancePagination: function (totalPages) {
      const state = this.performanceState;
      if (!state || !state.pagination) {
        return;
      }
      state.pagination.innerHTML = '';
      if (totalPages <= 1) {
        return;
      }
      const createButton = (label, page, isActive) => {
        const button = document.createElement('button');
        button.type = 'button';
        button.textContent = label;
        button.className = isActive ? 'cta-pagination-current' : 'button';
        button.addEventListener('click', () => {
          if (state.page === page) {
            return;
          }
          state.page = page;
          this.renderPerformanceList();
        });
        return button;
      };
      if (state.page > 1) {
        state.pagination.appendChild(createButton('← Prev', state.page - 1, false));
      }
      let startPage = Math.max(1, state.page - 2);
      let endPage = Math.min(totalPages, startPage + 4);
      if (endPage - startPage < 4) {
        startPage = Math.max(1, endPage - 4);
      }
      if (startPage > 1) {
        state.pagination.appendChild(createButton('1', 1, false));
        if (startPage > 2) {
          const dots = document.createElement('span');
          dots.className = 'cta-pagination-dots';
          dots.textContent = '…';
          state.pagination.appendChild(dots);
        }
      }
      for (let page = startPage; page <= endPage; page++) {
        state.pagination.appendChild(createButton(String(page), page, page === state.page));
      }
      if (endPage < totalPages) {
        if (endPage < totalPages - 1) {
          const dotsEnd = document.createElement('span');
          dotsEnd.className = 'cta-pagination-dots';
          dotsEnd.textContent = '…';
          state.pagination.appendChild(dotsEnd);
        }
        state.pagination.appendChild(createButton(String(totalPages), totalPages, false));
      }
      if (state.page < totalPages) {
        state.pagination.appendChild(createButton('Next →', state.page + 1, false));
      }
    },
    setPerformanceSortState: function () {
      const state = this.performanceState;
      if (!state) {
        return;
      }
      state.sortButtons.forEach(btn => {
        const sortKey = btn.getAttribute('data-sort-key');
        const active = sortKey === state.sortKey;
        btn.classList.toggle('is-active', active);
        btn.setAttribute('aria-pressed', active ? 'true' : 'false');
      });
    },
    exportData: function (format) {
      const start_date = this.currentDateStart;
      const end_date = this.currentDateEnd;
      const cta_id = this.currentCtaId;
      const params = new URLSearchParams({
        start_date,
        end_date,
        cta_id,
        format
      });
      const url = `${ctaAnalyticsData.ajaxUrl}?action=cta_export_analytics&${params}&nonce=${ctaAnalyticsData.nonce}`;
      const link = document.createElement('a');
      link.href = url;
      link.download = `cta-analytics-${format === 'csv' ? 'export' : 'export'}.${format === 'csv' ? 'csv' : 'json'}`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    },
    showTooltip: function (html, x, y) {
      if (!this.tooltipElement) return;
      this.tooltipElement.innerHTML = html;
      this.tooltipElement.style.display = 'block';
      this.tooltipElement.style.left = x + 10 + 'px';
      this.tooltipElement.style.top = y + 10 + 'px';

      // Adjust if tooltip goes off-screen
      const rect = this.tooltipElement.getBoundingClientRect();
      if (rect.right > window.innerWidth) {
        this.tooltipElement.style.left = x - rect.width - 10 + 'px';
      }
      if (rect.bottom > window.innerHeight) {
        this.tooltipElement.style.top = y - rect.height - 10 + 'px';
      }
    },
    hideTooltip: function () {
      if (this.tooltipElement) {
        this.tooltipElement.style.display = 'none';
      }
    },
    formatChartDate: function (dateStr) {
      const date = new Date(dateStr);
      return date.toLocaleDateString('en-US', {
        month: 'short',
        day: 'numeric'
      });
    },
    formatDateDisplay: function (dateStr) {
      const date = new Date(dateStr);
      return date.toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      });
    },
    formatNumber: function (num) {
      return new Intl.NumberFormat('en-US').format(num);
    },
    formatDateTime: function (dateTimeStr) {
      const date = new Date(dateTimeStr);
      return date.toLocaleString('en-US', {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit'
      });
    },
    truncateUrl: function (url) {
      try {
        const urlObj = new URL(url);
        const path = urlObj.pathname + urlObj.search;
        return path.length > 40 ? path.substring(0, 40) + '…' : path;
      } catch (e) {
        return url.length > 40 ? url.substring(0, 40) + '…' : url;
      }
    },
    escapeHtml: function (text) {
      const map = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#039;'
      };
      return text.replace(/[&<>"']/g, m => map[m]);
    }
  };

  // Initialize on document ready
  document.addEventListener('DOMContentLoaded', function () {
    Analytics.init();
  });

  // Expose to global scope
  window.Analytics = Analytics;
})(jQuery);
// ES6 Export
/* harmony default export */ __webpack_exports__["default"] = (Analytics);

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Check if module exists (development only)
/******/ 		if (__webpack_modules__[moduleId] === undefined) {
/******/ 			var e = new Error("Cannot find module '" + moduleId + "'");
/******/ 			e.code = 'MODULE_NOT_FOUND';
/******/ 			throw e;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be isolated against other modules in the chunk.
!function() {
/*!*************************************************!*\
  !*** ./assets/js/admin/components/analytics.js ***!
  \*************************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _modules_pages_analytics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modules/pages/analytics */ "./assets/js/admin/modules/pages/analytics.js");
/**
 * CTA Manager - Analytics Page Entry Point
 *
 * Entry point for the Analytics page (cta-manager-analytics).
 * Displays CTA performance metrics, charts, and tracking data.
 *
 * When bundled with npm, this file will import:
 * - pages/analytics (CTAAnalytics module)
 *
 * External Dependencies:
 * - Chart.js (loaded via CDN)
 *
 * Dependencies (loaded via admin.js):
 * - CTCAdmin, ctaModalAPI
 *
 * Output: /assets/js/minimized/admin/analytics.js
 *
 * @package CTA_Manager
 * @since 1.0.0
 */

// ES6 Module Imports (uncomment when bundling with npm)

(function ($) {
  'use strict';

  /**
   * Analytics Page Controller
   */
  window.CTAAnalyticsPage = window.CTAAnalyticsPage || {
    /**
     * Required modules for this page
     */
    modules: {
      analytics: 'CTAAnalytics'
    },
    /**
     * External dependencies
     */
    externals: {
      chartJs: 'Chart'
    },
    /**
     * Initialize the Analytics page
     */
    init: function () {
      // Wait for admin app to be ready
      $(document).on('ctaAdminReady', this.onAdminReady.bind(this));

      // If admin is already ready, initialize now
      if (window.CTAAdminApp) {
        this.onAdminReady();
      }
    },
    /**
     * Called when admin app is ready
     */
    onAdminReady: function () {
      // Verify Chart.js is loaded
      if (typeof window.Chart === 'undefined') {
        console.warn('CTAAnalytics: Chart.js not loaded');
      }

      // Analytics module self-initializes via pages/analytics.js

      // Trigger page ready event
      $(document).trigger('ctaAnalyticsReady', [this]);
    }
  };

  // Initialize on document ready
  $(function () {
    window.CTAAnalyticsPage.init();
  });
})(jQuery);
}();
/******/ })()
;